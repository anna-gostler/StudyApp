from root: 
docker-compose -f docker-compose-dev.yml up
run DemoApplication.java 

localhost:8080

if sth already listening to 8080:
netstat -ano | findstr :8080
taskkill /PID <last column of result not 0> /F
****************************************
https://milanwittpohl.com/projects/tutorials/full-stack-web-app/the-backend-with-java-and-spring

shift strg p = command palette
Spring Initializr -> create gradle project

build.gradle file: add -web

> reimporting the dependencies

spring lingo
Endpoints -> controllers 

MVC model:
model is the data that our application serves up. 
view could be a web page that we render using spring. 
The controller gets the data, by referencing the model, and provides the view with the necessary information. 
(spring not used to render view)
=> endpoint is the controller, as it provides a response to a web-request. 
To define a new controller we create
    a new package called controller
    a new java class called HelloWorldController


1. Declare our new class as controller

use a stereotype annotation
@Restcontroller is a specialisation of the @Controller annotation

@RestController
public class HelloWorldController {}

2. Create the endpoint

To create the endpoint we simply define a method. 
could call a different class and return any kind of object. 

public String sayHelloWorld(){
	return "Hello World!";
}

3. Define the path and request type of the endpoint

map path and request type to this endpoint.

@GetMapping("/sayhello")
public String sayHelloWorld(){
	return "Hello World!";
}

Your class should look like this now

package com.milanwittpohl.playgroundwebbackend.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloWorldController {

    @GetMapping("/sayhello")
    public String sayHelloWorld(){
        return "Hello World!";
    }

}

run DemoApplication.java -> localhost:8080/sayhello

--------------------------------------------------------------------------------------------------------------------------------------------

Working with data

define todo-Object 
implement endpoints to read, write, update and delete entries.
tell Spring that we want to work with data.

use MongoDB, but the setup is similar for other databases. 
add dependency org.springframework.boot:spring-boot-starter-data-mongodb in build.gradle

implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'

>> instead: (not ...)
in build.gradle
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
runtimeOnly 'mysql:mysql-connector-java'
>>

You also need to have a running mongoDB instance on your machine. 
Probably the simplest way to do that is to use a simple docker-compose file. 
For now install docker and create a new file in your project root directory (not in the spring project) 
called docker-compose-dev.yml. Insert the following code and replace the placeholders.

version: '3'
services:
  playground-web-db:
    image: mongo:4.2.2
    environment:
      MONGO_INITDB_DATABASE: playground-web
    ports:
      - 27017:27017

start the database 
run in the terminal from your project root folder:
Leave the terminal window open.

********************************************
docker-compose -f docker-compose-dev.yml up
********************************************


structure application
create:
* data object that describes our ToDo-Object
* repository that talks to the database
* service that handles additional business logic
* controller to accept request to read, create, update and delete entries

Creating the data object

create package called data
java class called ToDo. 

package com.milanwittpohl.playgroundwebbackend.data;

public class ToDo {
    private String id;
    private String title;
    private Boolean completed;
}

title and completed will be set by the user
id should only be touched by the framework to ensure its integrity. 
@Id: marks the field as primary key and auto generates a value
set up a constructor and getter methods for all of our properties.

package com.milanwittpohl.playgroundwebbackend.data;
import org.springframework.data.annotation.Id;

public class ToDo {
    @Id
    private String id;
    private String title;
    private Boolean completed;

    public ToDo(String title, Boolean completed){
        this.title = title;
        this.completed = completed;
    }

    public String getId() {return id;}

    public String getTitle() {return title;}

    public Boolean getCompleted() {return completed;}
}

Creating a repository

repository interacts with data base. 
To interact with a mongo-database we simply create an interface that extends the MonogRepository. 

ToDoRepository in package repository
When extending the MonogRepository we have to provide two parameters, as it uses generics:
1. entity that we want to use -> ToDo class. 
2. parameter that tells spring the type of the id attribute, in our case that is a string. 

package com.milanwittpohl.playgroundwebbackend.repository;

import com.milanwittpohl.playgroundwebbackend.data.ToDo;
import org.springframework.data.mongodb.repository.MongoRepository;

public interface ToDoRepository extends MongoRepository<ToDo, String> {}

Creating the service

package service > ToDoService.java
holds business logic: work with the data
(we don't have any business logic)
However we need to define a few methods to read, create, update and delete entities.

add @Service annotation to class. 
add our repository as a private property so that we can use it. 
This is where Springs constructor-injection comes into play. 
add the annotation @Autowired and spring makes sure we have an instance on runtime. 

add methods to
    get all todos
    get a single todo by id
    save a new or existing todo
    delete a single todo by id

package com.milanwittpohl.playgroundwebbackend.service;

import com.milanwittpohl.playgroundwebbackend.data.ToDo;
import com.milanwittpohl.playgroundwebbackend.exception.EntityNotFoundException;
import com.milanwittpohl.playgroundwebbackend.repository.ToDoRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ToDoService {

    @Autowired
    private ToDoRepository toDoRepository;

    public List<ToDo> findAll(){
        return toDoRepository.findAll();
    }

    public ToDo findById(String id){
        return toDoRepository.findById(id).orElseThrow(EntityNotFoundException::new);
    }

    public ToDo save(ToDo toDo){
        return toDoRepository.save(toDo);
    }

    public void deleteById(String id){
        toDoRepository.deleteById(id);
    }

}

If we look up an entity by its id, possible that no entity matches the given id. 
That is why our repository returns an Optional of a ToDo. 
An optional can either contain the entity or not.  
create exception in package exception

package com.milanwittpohl.playgroundwebbackend.exception;
public class EntityNotFoundException extends RuntimeException {}

Creating the controller

controller package > ToDoController

package com.milanwittpohl.playgroundwebbackend.controller;

import com.milanwittpohl.playgroundwebbackend.data.ToDo;
import com.milanwittpohl.playgroundwebbackend.service.ToDoService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/todo")
public class ToDoController {

    @Autowired
    private ToDoService toDoService;

    @GetMapping
    public List<ToDo> findAll(){
        return toDoService.findAll();
    }

    @GetMapping("/{id}")
    public ToDo findById(@PathVariable String id){
        return toDoService.findById(id);
    }

    @PostMapping
    public ToDo create(@RequestBody ToDo toDo){
        return toDoService.save(toDo);
    }

    @PutMapping("/{id}")
    public ToDo update(@RequestBody ToDo toDo){
        return toDoService.save(toDo);
    }

    @DeleteMapping("/{id}")
    public void deleteById(@PathVariable String id){
        toDoService.deleteById(id);
    }
}

@RequestMapping : This way all endpoints are mapped at /api/todo. 
To get a specific todo we want to pass the id via the url (e.g. localhost:8080/api/todo/5d6e53da5c88f13387cb8fa3). 
That's why we need to tell Spring that the url contains a variable, the id. 
This is done by using the curly brackets on the get mapping annotation and the @PathVariable annotation in the method header 
To create or update an entity we need to transmit a json-body containing the information. We let Spring know by using @RequestBody. 

// For creation
{
    "title":"Finish it",
    "completed":false
}
// For updating
{
    "id": "5d6e54bd5c88f133b8209f34",
    "title": "Finish it",
    "completed": true
}

Run the application and you will see that you can get, create, update and delete todos.

********************************************
// Get all
curl -X GET http://localhost:8080/api/todo

// Create one
curl -X POST http://localhost:8080/api/todo/ ^
-H Content-Type:application/json ^
-d "{\"title\":\"Finish it\",\"completed\":false}"

// Get one
curl -X GET http://localhost:8080/api/todo/<ID of ToDo>

// Update one
curl -X PUT ^
  http://localhost:8080/api/todo/5ea8af3ed42d09767a3348e2 ^
  -H Content-Type:application/json ^
  -d "{ \"id\": \"5ea8af3ed42d09767a3348e2\", \"title\": \"Updated\", \"completed\": true}"

// Delete one
curl -X DELETE http://localhost:8080/api/todo/<ID of ToDo>

Securing the Endpoints

We could implement a user management service, 
but for now we will just secure our endpoints and add one user for authentication.

add new dependency to gradle file
org.springframework.boot:spring-boot-starter-security

configure spring on how to secure our application. 
Configuration in spring can be done using classes and annotation. 

package configuration > WebSecurityConfiguration.java
add the @Configuration annotation to the class 
use this configuration to define the access management -> extend the WebSecurityConfigurerAdapter class 

@Configuration
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {}

override the configure method of the WebSecurityConfigurerAdapter class

@Override
protected void configure(HttpSecurity http) throws Exception {
    http
         .authorizeRequests().antMatchers("/api/**").authenticated()
         .and()
         .httpBasic()
         .and()
         .exceptionHandling()
             .authenticationEntryPoint(restAuthenticationEntryPoint)
         .and()
         .formLogin()
		        .loginProcessingUrl("/api/login")
            .successHandler(loginSuccessHandler)
            .failureHandler(new SimpleUrlAuthenticationFailureHandler());
 }

Within the method we configure the HttpSecurity instance http for our application. 
We chain different commands together using the and-method. 
As there is a lot that is going on here, we will go through it line by line.

Overall Protection

First we tell our app to secure (authorise) all request to /api/. 
Any http request needs to be authenticated via http-basic 
An entry point used to send back a 401 Unauthorized response if a user tries to access a protected webpage
While we could send the credentials with every request, 
we want to have a login page where the user can login and then get a >> token. 
This way we can identify each >> user session more easily and we don't need to send our credentials every time 

The parameter "loginProcessingUrl" tells the app the url where we send the credentials to. 
We will use this in our frontend. 

define two handlers, one if the login succeeds and one if the login fails

Login Page - Success Handler

Our success handler is a new class in our configuration package, 
that extends the SimpleUrlAuthenticationSuccessHandler. 
Basically, we dont want our backend to return a 200 Okay response if the login was successful. 
The SimpleUrlAuthenticationSuccessHandler which we extend here, 
does that but also redirects the user to a certain URL. 
We don't want that, we just want to return a 200 response. 
To make our life easy, we simply copy the code of the SimpleUrlAuthenticationSuccessHandler 
and remove the logic for the redirect. Leaving us with this code: 

@Component("loginSuccessHandler")
public class LoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    private RequestCache requestCache = new HttpSessionRequestCache();

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException {

        SavedRequest savedRequest = requestCache.getRequest(request, response);

        if (savedRequest == null) {
            clearAuthenticationAttributes(request);
            return;
        }
        String targetUrlParam = getTargetUrlParameter();
        if (isAlwaysUseDefaultTargetUrl() || (targetUrlParam != null && StringUtils.hasText(request.getParameter(targetUrlParam)))) {
            requestCache.removeRequest(request, response);
            clearAuthenticationAttributes(request);
            return;
        }

        clearAuthenticationAttributes(request);
    }

    public void setRequestCache(RequestCache requestCache) {
        this.requestCache = requestCache;
    }

}

We will need to inject this class our WebSecurityConfigurerAdapter. 
That is why we need the @Component annotation to tell spring, that we want to inject this class later. 

Login Page - Failure Handler

return a 401 Unauthorized response
simply use the SimpleUrlAuthenticationFailureHandler class. 

Exception Handling - RestAuthenticationEntryPoint
return a 401 response.
class called RestAuthenticationEntryPoint.java and insert the following code. 


@Component
public final class RestAuthenticationEntryPoint
        implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, org.springframework.security.core.AuthenticationException authException) throws IOException, ServletException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
    }
}

Inject the Handler in the WebSecurityConfiguration

To use the handlers, we need to inject them into our WebSecurityConfiguration.

@Configuration
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    private LoginSuccessHandler loginSuccessHandler;

    @Autowired
    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
		...

Defining Users with Credentials

If we now run the application any request to /api/todo/ will fail as we are unauthorised. 
However, our first endpoint /sayHello is still accessible 

Now we need to configure a simple user that is allowed to access /api/todo/.
To do so we add two methods in our WebSecurityConfiguration 

@Bean
public UserDetailsService userDetailsService() {
  String password = "password";
  String username = "user";
  InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
  String encodedPassword = passwordEncoder().encode(password);
  manager.createUser(User.withUsername(username).password(encodedPassword).roles("USER").build());
  return manager;
}

@Bean
public PasswordEncoder passwordEncoder() {
  return new BCryptPasswordEncoder();
}

Via the first method we tell spring to store user details within the application memory and create a new user 
To encode the password we define a password encoder in the second method 
You may have noticed that we use a new annotation on both methods called @Bean. 
With that annotation we tell spring to create a java bean. 
Without the annotation our configuration could not access those methods. 
configuration class:

package com.milanwittpohl.playgroundwebbackend.configuration;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.access.intercept.FilterSecurityInterceptor;
import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;

@Configuration
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;

    @Autowired
    private LoginSuccessHandler loginSuccessHandler;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests().antMatchers("/api/**").authenticated()
                .and()
                .httpBasic()
                .and()
                .exceptionHandling()
                    .authenticationEntryPoint(restAuthenticationEntryPoint)
                .and()
                .formLogin()
                    .loginProcessingUrl("/api/login")
                    .successHandler(loginSuccessHandler)
                    .failureHandler(new SimpleUrlAuthenticationFailureHandler());
    }

   @Bean
    public UserDetailsService userDetailsService() {
        String username = "user";
        String password = "password";
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        String encodedPassword = passwordEncoder().encode(password);
        manager.createUser(User.withUsername(username).password(encodedPassword).roles("USER").build());
        return manager;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

If we now run our application our todo endpoints are secure and can only be accessed using basic authentication. 
An easy way to test this, is to use Postman. 

Building the application

we use gradle for build automation. 
So all we need to do is open up a terminal, navigate to our project folder, and execute

gradle build

left panel: gradle tasks > build > build > run button

This builds us a .jar file under ./build/libs/.

To run our application simply execute

java -jar ./build/libs/backend-0.0.1-SNAPSHOT.jar

